// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearNotificationEvents = `-- name: ClearNotificationEvents :exec
DELETE FROM vn_last_notification_event WHERE date_sent < now() - interval '1 hour' * $1::integer
`

// ClearNotificationEvents deletes old notification exem.
func (q *Queries) ClearNotificationEvents(ctx context.Context, numberOfHours int) error {
	_, err := q.db.Exec(ctx, clearNotificationEvents, numberOfHours)
	return err
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT codigo_item, preco FROM item_preco WHERE codigo_prazo == $1 ORDER BY codigo_item, codigo_unidade DESC
`

type GetAllProductsRow struct {
	CodigoItem float64
	Preco      float64
}

// GetAllProducts is used to calculate the hash of the products and prices. Always sorted in a predictable order.
// This is used to check if the prices have changed.
func (q *Queries) GetAllProducts(ctx context.Context, codigoPrazo int) ([]GetAllProductsRow, error) {
	rows, err := q.db.Query(ctx, getAllProducts, codigoPrazo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProductsRow
	for rows.Next() {
		var i GetAllProductsRow
		if err := rows.Scan(&i.CodigoItem, &i.Preco); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentUpdate = `-- name: GetMostRecentUpdate :one
SELECT alteracao_preco FROM item_preco ORDER BY alteracao_preco DESC LIMIT 1
`

// GetMostRecentUpdate retrieves the most recent update of the prices.
func (q *Queries) GetMostRecentUpdate(ctx context.Context) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, getMostRecentUpdate)
	var alteracao_preco pgtype.Date
	err := row.Scan(&alteracao_preco)
	return alteracao_preco, err
}

const getNotificationEvent = `-- name: GetNotificationEvent :one
SELECT event_type, codigo_item, date_sent FROM vn_last_notification_event WHERE event_type == $1 and codigo_item == $2
`

type GetNotificationEventParams struct {
	EventType  string
	CodigoItem float64
}

func (q *Queries) GetNotificationEvent(ctx context.Context, arg GetNotificationEventParams) (VnLastNotificationEvent, error) {
	row := q.db.QueryRow(ctx, getNotificationEvent, arg.EventType, arg.CodigoItem)
	var i VnLastNotificationEvent
	err := row.Scan(&i.EventType, &i.CodigoItem, &i.DateSent)
	return i, err
}

const getPriceWatcher = `-- name: GetPriceWatcher :one
SELECT last_update, prices_hash FROM vn_price_update_watcher ORDER BY last_update DESC LIMIT 1
`

// GetPriceWatcher retrieves the last hash and update time of the prices.
func (q *Queries) GetPriceWatcher(ctx context.Context) (VnPriceUpdateWatcher, error) {
	row := q.db.QueryRow(ctx, getPriceWatcher)
	var i VnPriceUpdateWatcher
	err := row.Scan(&i.LastUpdate, &i.PricesHash)
	return i, err
}

const getProductsPrices = `-- name: GetProductsPrices :many
SELECT codigo_item, codigo_unidade, preco, alteracao_preco FROM item_preco WHERE codigo_item = ANY($2::pg_catalog.numeric[]) and codigo_prazo == $1 ORDER BY codigo_item, alteracao_preco DESC
`

type GetProductsPricesParams struct {
	CodigoPrazo  int
	CodigosItens []float64
}

type GetProductsPricesRow struct {
	CodigoItem     float64
	CodigoUnidade  int
	Preco          float64
	AlteracaoPreco pgtype.Date
}

// Get the price of products from item_preco with a given codigo_prazo.
// Later we'll filter by the most recent alteracao_preco. If there are two with the same
// alteracao_preco, we'll send a warning to the admin through email.
func (q *Queries) GetProductsPrices(ctx context.Context, arg GetProductsPricesParams) ([]GetProductsPricesRow, error) {
	rows, err := q.db.Query(ctx, getProductsPrices, arg.CodigoPrazo, arg.CodigosItens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsPricesRow
	for rows.Next() {
		var i GetProductsPricesRow
		if err := rows.Scan(
			&i.CodigoItem,
			&i.CodigoUnidade,
			&i.Preco,
			&i.AlteracaoPreco,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerNotificationEvent = `-- name: RegisterNotificationEvent :exec
INSERT INTO vn_last_notification_event (event_type, codigo_item, date_sent) VALUES ($1, $2, now())
`

type RegisterNotificationEventParams struct {
	EventType  string
	CodigoItem float64
}

func (q *Queries) RegisterNotificationEvent(ctx context.Context, arg RegisterNotificationEventParams) error {
	_, err := q.db.Exec(ctx, registerNotificationEvent, arg.EventType, arg.CodigoItem)
	return err
}

const updatePriceWatcher = `-- name: UpdatePriceWatcher :exec
INSERT INTO vn_price_update_watcher (last_update, prices_hash) VALUES (now(), $1)
`

// UpdatePriceWatcher updates the last hash and update time of the prices.
func (q *Queries) UpdatePriceWatcher(ctx context.Context, pricesHash string) error {
	_, err := q.db.Exec(ctx, updatePriceWatcher, pricesHash)
	return err
}
